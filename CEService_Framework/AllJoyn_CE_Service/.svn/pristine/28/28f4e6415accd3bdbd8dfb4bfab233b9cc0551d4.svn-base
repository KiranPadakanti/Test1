/******************************************************************************
 *
 * Copyright 2008-2013, Silicon Image, Inc.  All rights reserved.
 * No part of this work may be reproduced, modified, distributed, transmitted,
 * transcribed, or translated into any language or computer format, in any form
 * or by any means without written permission of: Silicon Image, Inc., 1060
 * East Arques Avenue, Sunnyvale, California 94085
 *
 *****************************************************************************/
/**
 * @file os_socket.h
 *
 * This file contains declarations to abstract BSD sockets
 *
 * Don't use source control directives!
 * Don't use source control directives!
 * Don't use source control directives!
 *
 *****************************************************************************/

#ifndef _OS_SOCKET_H
#define _OS_SOCKET_H

/** \addtogroup OSAL OS Abstraction Layer
 * @{
 * This provides the Abstraction Layer interface between ULMUS and OS library
 */

#ifdef WIN32
#include <WinSock.h>
#include <WS2tcpip.h>
#else
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#endif

#include <sii_types.h>
#include "os_types.h"

#define IP_STRING_LENGTH 16
/* NOTES:
 Thin layer to abstract minor differences in BSD sockets across OSs. General rules:
 -Socket functions have primarily been renamed with prefix 'SiiNet' and follow the original semantics. Refer to the corresponding Linux man pages for API documentation.
 -Socket data structures have been typedef'ed with prefix 'SiiOs'. Simple data types such as size_t have not been changed.
 -The BSD flags (such as SOCK_STREAM) have not been re-defined with 'SII_' prefix. If any OS-specific translation is required,
 it will be done inside the functions below. Programmers should continue to use the flags applying the original BSD semantics.

 FYI - Windows porting considerations
 Use setsockopt instead of fcntl; Windows does not implement fcntl
 Cannot use read/readv and write/writev on socket calls in Windows. However, WSASend/WSARecv provides similar functionality - will need translation in Windows. It would have been better to standardize on sendmsg/recvmsg, but then we lose scatter-gather I/O.
 */

typedef struct sockaddr SiiOsSockAddr_t;
typedef struct sockaddr_in SiiOsSockAddrIn_t;
typedef fd_set SiiOsFdSet_t;

/**
 *  @name Socket
 *  @{
 **/

/************************************************************************//**
 *
 * @brief Get result of last socket or file operation (public API)
 *
 * @return error code
 *
 * @note If there are any variations from BSD errno codes returned in Linux
 *       user-space, those variations will be handled here and standardized
 *       to the behavior expected in Linux user space. User must follow all
 *       rules of the "errno" variable for reading in POSIX environment.
 *
 ******************************************************************************/
int32_t SiiNetGetErrno(void);

uint32_t SiiOsparseIpFromUrl(char *url);

SiiOsStatus_t SiiOsSocketStartConnect(int32_t sock, ipAddr_t remIpAddr,
		port_t remPort, int32_t retryCount);
/************************************************************************//**
 *
 * @brief Create a socket (public API)
 *
 * @param[in]     domain          usually PF_LOCAL or PF_INET(6), see "man socket"
 * @param[in]     type            for TCP: SOCK_STREAM@n
 *                                for UDP: SOCK_DGRAM@n
 *                                see "man socket" for more information
 * @param[in]     protocol        0: choose automatically@n
 *                                see "man socket" for more information
 *
 * @return file descriptor
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiOsSocket(int32_t domain, int32_t type, int32_t protocol);

/************************************************************************//**
 *
 * @brief Bind a socket to a local address and port (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 * @param[in]     pAddr           local address@n
 *                                see "man socket" for more information
 * @param[in]     addrLen         length of data structure (pAddr) points to
 *
 * @retval 0 success
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetBind(int32_t fd, const SiiOsSockAddr_t *pAddr, uint32_t addrLen);

/*************************************************************************//**
 *
 * @brief Make a socket "non blocking" (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 *
 * @retval 0 success
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetMakeNonBlocking(int32_t fd);

/*************************************************************************//**
 *
 * @brief Make a socket "blocking" (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 *
 * @retval 0 success
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetMakeBlocking(int32_t fd);

/*************************************************************************//**
 *
 * @brief Close a socket (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 *
 * @retval 0 success
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetClose(int32_t fd);

/*************************************************************************//**
 *
 * @brief Get socket name (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 * @param[out]    pAddr           buffer for name
 * @param[in,out] addrLen         in: buffer size, out: length of name
 *
 * @retval 0 success
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetGetSockName(int32_t fd, SiiOsSockAddr_t *pAddr, uint32_t *len);

/*************************************************************************//**
 *
 * @brief Connect a socket to a remote address and port (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 * @param[in]     pAddr           remote address@n
 *                                see "man socket" for more information
 * @param[in]     addrLen         length of data structure (pAddr) points to
 *
 * @retval 0 success
 * @retval -1 error
 *
 * @note For connectionless socket types, just set the default address to send
 *       to and the only address from which to accept transmissions.
 *
 ******************************************************************************/
int32_t SiiNetConnect(int32_t fd, SiiOsSockAddr_t *pAddr, uint32_t addrLen);

/*************************************************************************//**
 *
 * @brief Set socket option (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 * @param[in]     level           protocol level
 * @param[in]     optname         option name
 * @param[in]     optval          option value
 * @param[in]     optlen          option value size in bytes
 *
 * @retval 0 success
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetSetSockOpt(int32_t fd, int32_t level, int32_t optname,
		const void *optval, uint32_t optlen);

/*************************************************************************//**
 *
 * @brief Prepare to accept connections on socket (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 * @param[in]     backlog         number of connection requests which will
 *                                be queued before further requests are refused
 *
 * @retval 0 success
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetListen(int32_t fd, int32_t backlog);

/*************************************************************************//**
 *
 * @brief Await a connections on socket (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 * @param[out]    pAddr           remote address@n
 *                                see "man 2 accept" for more information
 * @param[in,out] pAddrLen        in: buffer size, out: length of address
 *
 * @return new socket descriptor
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetAccept(int32_t fd, SiiOsSockAddr_t *pAddr, uint32_t *pAddrLen);

/*************************************************************************//**
 *
 * @brief Shut down all or part of the connection (public API)
 *
 * @param[in]     fd              socket descriptor from @ref SiiOsSocket()
 * @param[in]     how             SHUT_RD   = No more receptions@n
 *                                SHUT_WR   = No more transmissions@n
 *                                SHUT_RDWR = No more receptions or transmissions.
 *
 * @return new socket descriptor
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetShutdown(int32_t fd, int32_t how);

/*************************************************************************//**
 *
 * @brief Wait for sockets to become readable or writable (public API)
 *
 * @param[in]     nfds            see "man select"
 * @param[in,out] readfds         socket set for reading, see "man select"
 * @param[in,out] writefds        socket set for writing, see "man select"
 * @param[in,out] errorfds        socket set for errors, see "man select"
 * @param[in]     timeout         timeout, see "man select"
 *
 * @return number of "active" file descriptors
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetSelect(int32_t nfds, SiiOsFdSet_t * readfds,
		SiiOsFdSet_t * writefds, SiiOsFdSet_t * errorfds,
		SiiOsTimeVal_t * timeout);

/*************************************************************************//**
 *
 * @brief Remove socket from socket set (public API)
 *
 * @param[in]     fd              socket to remove from socket set
 * @param[in,out] fdset           socket set
 *
 ******************************************************************************/
void SII_NET_FD_CLR(int32_t fd, SiiOsFdSet_t *fdset);

/*************************************************************************//**
 *
 * @brief Check if socket is in socket set (public API)
 *
 * @param[in]     fd              socket to remove from socket set
 * @param[in]     fdset           socket set
 *
 ******************************************************************************/
int32_t SII_NET_FD_ISSET(int32_t fd, const SiiOsFdSet_t *fdset);

/*************************************************************************//**
 *
 * @brief Add socket to socket set (public API)
 *
 * @param[in]     fd              socket to add to socket set
 * @param[in,out] fdset           socket set
 *
 ******************************************************************************/
void SII_NET_FD_SET(int32_t fd, SiiOsFdSet_t *fdset);

/*************************************************************************//**
 *
 * @brief Remove every socket from socket set (public API)
 *
 * @param[in,out] fdset           socket set
 *
 ******************************************************************************/
void SII_NET_FD_ZERO(SiiOsFdSet_t *fdset);

/*************************************************************************//**
 *
 * @brief Write multiple buffers to file or socket (public API)
 *
 * @param[in]     fd              socket or file
 * @param[in]     iov             buffers
 * @param[in]     iovcnt          number of buffers
 *
 * @return number of bytes written
 * @retval -1 error
 *
 * @remarks FYI - for windows, use WSASend()
 *
 ******************************************************************************/
int32_t SiiNetWriteV(int32_t fd, const SiiOsIoVec_t *iov, int32_t iovcnt);

/*************************************************************************//**
 *
 * @brief Write buffer to file or socket (public API)
 *
 * @param[in]     fd              socket or file
 * @param[in]     buf             buffer
 * @param[in]     count           number of bytes
 *
 * @return number of bytes written
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetWrite(int32_t fd, const void *buf, size_t count);

/*************************************************************************//**
 *
 * @brief Read multiple buffers from file or socket (public API)
 *
 * @param[in]     fd              socket or file
 * @param[in]     iov             buffers
 * @param[in]     iovcnt          number of buffers
 *
 * @return number of bytes read
 * @retval -1 error
 *
 * @remarks FYI - for windows, use WSARecv()
 *
 ******************************************************************************/
int32_t SiiNetReadV(int32_t fd, const SiiOsIoVec_t *iov, int32_t iovcnt);

/*************************************************************************//**
 *
 * @brief Read buffer from file or socket (public API)
 *
 * @param[in]     fd              socket or file
 * @param[in]     buf             buffer
 * @param[in]     count           number of bytes
 *
 * @return number of bytes read
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetRead(int32_t fd, void *buf, size_t count);

/*************************************************************************//**
 *
 * @brief Send buffer via socket to a remote host (public API)
 *
 * @param[in]     fd              socket or file
 * @param[in]     buf             buffer
 * @param[in]     count           number of bytes
 * @param[in]     flags           see "man sendto"
 * @param[in]     pAddr           remote address@n
 *                                see "man socket" for more information
 * @param[in]     addrLen         length of data structure (pAddr) points to
 *
 * @return number of bytes written
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetSendto(int32_t fd, const void *buf, size_t count, int32_t flags,
		const SiiOsSockAddr_t *pAddr, int32_t addrLen);

/*************************************************************************//**
 *
 * @brief Receive buffer via socket from a remote host (public API)
 *
 * @param[in]     fd              socket or file
 * @param[in]     buf             buffer
 * @param[in]     count           number of bytes
 * @param[in]     flags           see "man recvfrom"
 * @param[in]     pAddr           remote address@n
 *                                see "man socket" for more information
 * @param[in,out] pAddrLen        in: buffer size, out: length of address
 *
 * @return number of bytes read
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiNetRecvfrom(int32_t fd, void *buf, size_t count, int32_t flags,
		SiiOsSockAddr_t *pAddr, uint32_t *pAddrLen);

/*****************************************************************************/
/**
 * This will look up the interface name based on the ip address provided.
 * This will not work if bonding drivers are used to have many ip address to
 * one interface. Such bonding driver is not commonly used in CE devices
 *
 * @param[in]  ipAddr  - For which the Interface name is looked up.
 * @param[out] pIfName - Where the looked up interface name is copied. The size
 *                       of the buffer passed should be IFNAMSIZ
 *
 * @return SII_OS_STATUS_SUCCESS            on success
 *         SII_OS_STATUS_ERR_INVALID_PARAM  if ifName pointer is NULL.
 *         SII_OS_STATUS_ERR_FAILED         if look up failed.
 *
 *****************************************************************************/
SiiOsStatus_t SiiNetGetIfName(SiiOsIpAddr_t ipAddr, char *pIfName);

/* Create two new sockets, of type TYPE in domain DOMAIN and using
 protocol PROTOCOL, which are connected to each other, and put file
 descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
 one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
int32_t SiiOsSocketpair(int32_t domain, int32_t type, int32_t protocol,
		int32_t fds[2]);

const char *SiiNetInetNtop(int af, struct in_addr *inAddr, char *dstIp,
		int socketLength);

uint32_t SiiOsGetMsgNosignalVal(void);
uint32_t SiiOsGetMsgDontWaitVal(void);
uint32_t SiiOsGetMsgMoreVal(void);

/* TODO Make return type as SiiOsStatus_t */
int SiiOsGetMacandIpAddressFromInterfaces(int8_t *g_IpaString,
		ethAddr_t *g_EthAddress, uint32_t *retInterface_num);

/****************************************************************************************
 Below APIs are not implemented - add these APIs only if absolutely necessary
 ****************************************************************************************/
/* Send a message described MESSAGE on socket FD.
 Returns the number of bytes sent, or -1 for errors.

 This function is a cancellation point and therefore not marked with
 .  */
#if 0
int32_t sendmsg
(
		int32_t fd,
		const struct msghdr *message,
		int32_t flags
);

/* Receive a message as described by MESSAGE from socket FD.
 Returns the number of bytes read or -1 for errors.

 This function is a cancellation point and therefore not marked with
 .  */
int32_t recvmsg(int32_t fd, struct msghdr *message, int32_t flags);

typedef SOCKADDR_ARG SII_SOCKADDR_ARG;
/* Put the address of the peer connected to socket FD into *ADDR
 (which is *LEN bytes long), and its actual length into *LEN.  */
int32_t SiiNetGetPeerName
(
		int32_t fd,
		SII_SOCKADDR_ARG addr,
		uint32_t *len
)
{
	return getpeername(fd, (SOCKADDR_ARG) addr,
			(uint32_t *)len);
}

/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.

 This function is a cancellation point and therefore not marked with
 .  */
int32_t SiiNetSend
(
		int32_t fd,
		const void *buf,
		size_t n,
		int32_t flags
)
{
	return send(fd, buf, n, flags);
}

/* Read N bytes into BUF from socket FD.
 Returns the number read or -1 for errors.

 This function is a cancellation point and therefore not marked with
 .  */
int32_t SiiNetRecv
(
		int32_t fd,
		void *buf,
		size_t n,
		int32_t flags
)
{
	return recv(fd, buf, n, flags);
}

#endif /* not implemented */
/** @}*//* Socket */
/** @}*//* OS Abstraction Layer */

#endif /* _OS_SOCKET_H */
