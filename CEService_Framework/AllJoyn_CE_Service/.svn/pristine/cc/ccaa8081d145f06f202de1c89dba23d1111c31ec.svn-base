#include <stdio.h>
#include <signal.h>
#include <fstream>

#include <alljoyn/BusAttachment.h>
#include <alljoyn/about/AboutIconService.h>
#include <alljoyn/about/AboutServiceApi.h>
#include <alljoyn/ce/CEService.h>
#include <alljoyn/ce/CEKeyCodes.h>

#include <CommonBusListener.h>
#include <CommonSampleUtil.h>

#include "CEServiceListenerImpl.h"
#include "PropertyStoreImpl.h"
#include "OptParser.h"
#include <alljoyn/services_common/LogModulesNames.h>

#include "unistd.h"
#include "sii_types.h"
#include "uda.h"

#include <alljoyn/CECTransport.h>

#define SERVICE_EXIT_OK       0
#define SERVICE_OPTION_ERROR  1

using namespace ajn;
using namespace services;

/** static variables need for sample */
static BusAttachment* msgBus = NULL;

static CEService* ceService = NULL;

static AboutIconService* aboutIconService = NULL;

static PropertyStoreImpl* propertyStore = NULL;

static CEServiceListenerImpl* ceServiceListener = NULL;

static CommonBusListener* busListener = NULL;

static SessionPort SERVICE_PORT;

bool_t udaStarted = false;

static void cleanup()
{

	if (AboutServiceApi::getInstance())
	{
		AboutServiceApi::DestroyInstance();
	}

	if (ceService)
	{
		delete ceService;
		ceService = NULL;
	}

	if (ceServiceListener)
	{
		delete ceServiceListener;
		ceServiceListener = NULL;
	}

	if (busListener)
	{
		msgBus->UnregisterBusListener(*busListener);
		delete busListener;
		busListener = NULL;
	}

	if (aboutIconService)
	{
		delete aboutIconService;
		aboutIconService = NULL;
	}

	if (propertyStore)
	{
		delete propertyStore;
		propertyStore = NULL;
	}

	/* Clean up msg bus */
	delete msgBus;
	msgBus = NULL;

}

/** Advertise the service name, report the result to stdout, and return the status code. */
QStatus AdvertiseName(TransportMask mask)
{
	QStatus status = ER_BUS_ESTABLISH_FAILED;
	if (msgBus->IsConnected() && msgBus->GetUniqueName().size() > 0)
	{
		status = msgBus->AdvertiseName(msgBus->GetUniqueName().c_str(), mask);
		//	std::cout << "AdvertiseName " << msgBus->GetUniqueName().c_str() << " ="
		//		<< QCC_StatusText(status) << std::endl;
	}
	return status;
}

/** Connect to the daemon, report the result to stdout, and return the status code. */
QStatus ConnectToDaemon()
{
	QStatus status;
	status = msgBus->Connect();

	if (ER_OK == status)
	{
		//std::cout << "Daemon connect succeeded." << std::endl;
	}
	else
	{
		std::cout << "Failed to connect daemon (" << QCC_StatusText(status)
				<< ")." << std::endl;
	}

	return status;
}

/** Start the message bus, report the result to stdout, and return the status code. */
QStatus StartMessageBus(void)
{
	QStatus status = msgBus->Start();

	if (ER_OK == status)
	{
		//std::cout << "BusAttachment started." << std::endl;
	}
	else
	{
		std::cout << "Start of BusAttachment failed (" << QCC_StatusText(status)
				<< ")." << std::endl;
	}

	return status;
}

int main(int argc, char**argv, char**envArg)
{
	QStatus status = ER_OK;
	char inpt[80] = { 0 };
	std::set<unsigned int> keyList;
	unsigned char lKsup[32] = { 0 };
	unsigned int la = 0;
//	std::cout << "AllJoyn Library version: " << ajn::GetVersion() << std::endl;
//	std::cout << "AllJoyn Library build info: " << ajn::GetBuildInfo()
//			<< std::endl;
//	QCC_SetLogLevels("ALLJOYN_ABOUT_SERVICE=7;");
//	QCC_SetLogLevels("ALLJOYN_ABOUT_ICON_SERVICE=7;");
//	QCC_SetDebugLevel(logModules::CE_MODULE_LOG_NAME,
//			logModules::ALL_LOG_LEVELS);

	OptParser opts(argc, argv);
	OptParser::ParseResultCode parseCode(opts.ParseResult());
	switch (parseCode)
	{
		case OptParser::PR_OK:
			break;

		case OptParser::PR_EXIT_NO_ERROR:
			return SERVICE_EXIT_OK;

		default:
			return SERVICE_OPTION_ERROR;
	}

	SERVICE_PORT = opts.GetPort();
	std::cout << "using port " << opts.GetPort() << std::endl;

	if (!opts.GetAppId().empty())
	{
		std::cout << "using appID " << opts.GetAppId().c_str() << std::endl;
	}

	la = opts.GetLA();

	printf("Logical Address of device is %d\n", la);

	/* Create message bus */
	msgBus = new BusAttachment(opts.GetAppName().c_str(), true);
	if (!msgBus)
	{
		status = ER_OUT_OF_MEMORY;
		return status;
	}

	if (ER_OK == status)
	{
		status = StartMessageBus();
	}

	if (ER_OK == status)
	{
		status = ConnectToDaemon();
	}

	busListener = new CommonBusListener(msgBus);
	busListener->setSessionPort(SERVICE_PORT);

	propertyStore = new PropertyStoreImpl(NULL, NULL);
	status = CommonSampleUtil::fillPropertyStore(propertyStore, opts.GetAppId(),
			opts.GetAppName(), opts.GetDeviceId(), opts.GetDeviceName(),
			opts.GetDefaultLanguage());
	propertyStore->Initialize();
	if (status != ER_OK)
	{
		std::cout << "Could not fill PropertyStore." << std::endl;
		cleanup();
		return 1;
	}

	status = CommonSampleUtil::prepareAboutService(msgBus, propertyStore,
			busListener, SERVICE_PORT);
	if (status != ER_OK)
	{
		std::cout << "Could not set up the AboutService." << std::endl;
		cleanup();
		return 1;
	}

	AboutService* aboutService = AboutServiceApi::getInstance();
	if (!aboutService)
	{
		std::cout << "Could not set up the AboutService." << std::endl;
		cleanup();
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	//aboutIconService
	std::ifstream infile("icon.png", std::ifstream::binary);

	// get size of file
	infile.seekg(0, infile.end);
	long size = infile.tellg();
	infile.seekg(0);

	// allocate memory for file content
	uint8_t* aboutIconContent = new uint8_t[size];
	// read content of infile
	infile.read((char *) aboutIconContent, size);
	infile.close();

	qcc::String mimeType("image/png");
	qcc::String url(""); //put your url here

	std::vector<qcc::String> interfaces;
	interfaces.push_back("org.alljoyn.Icon");
	aboutService->AddObjectDescription("/About/DeviceIcon", interfaces);

	aboutIconService = new AboutIconService(*msgBus, mimeType, url,
			(uint8_t *) aboutIconContent, size);
	status = aboutIconService->Register();
	if (status != ER_OK)
	{
		std::cout << "Could not register the AboutIconService." << std::endl;
		cleanup();
		return 1;
	}

	status = msgBus->RegisterBusObject(*aboutIconService);
	if (status != ER_OK)
	{
		std::cout << "Could not register the AboutIconService BusObject."
				<< std::endl;
		cleanup();
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	//CEService
	CEKeyCodes obj = CEKeyCodes();
	obj.getKeyListfromDeviceType(opts.GetDeviceType(), &keyList);
	obj.getKSUPfromKeyList(keyList, lKsup);
	ceServiceListener = new CEServiceListenerImpl(*busListener, la);
	ceService = new CEService(*msgBus, *propertyStore, *ceServiceListener,
			opts.GetDeviceType(), lKsup);

	interfaces.clear();
	interfaces.push_back("org.alljoyn.CE");
	aboutService->AddObjectDescription("/CE", interfaces);

	status = ceService->Register();
	if (status != ER_OK)
	{
		std::cout << "Could not register the CEService." << std::endl;
		cleanup();
		return 1;
	}

	status = msgBus->RegisterBusObject(*ceService);
	if (status != ER_OK)
	{
		std::cout << "Could not register the CEService BusObject." << std::endl;
		cleanup();
		return 1;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////

	/* UDA Application Initialization. Return with error if initialization fails */
	status = (QStatus) udaAppInit();
	udaStarted = true;
	if (status != ER_OK)
	{
		std::cout << "------------------------------------------"
						<< std::endl;
		std::cout << "UDA Daemon App is not available will not Log Command Data"
				<< std::endl;
		std::cout << "------------------------------------------"
						<< std::endl;
		status =  ER_OK;
		udaStarted = false;
	}

	const TransportMask SERVICE_TRANSPORT_TYPE = TRANSPORT_ANY;

	if (ER_OK == status)
	{
		status = AdvertiseName(SERVICE_TRANSPORT_TYPE);
	}

	if (ER_OK == status)
	{
		status = aboutService->Announce();
	}

	/* Perform the service asynchronously until the user signals for an exit. */
	while (true)
	{
		std::cout << "\t----------------Main Menu-----------------"
				<< std::endl;
		std::cout << "\t|1) Send Notify                           |"
				<< std::endl;
		std::cout << "\t|x) Exit                                  |"
				<< std::endl;
		std::cout << "\t------------------------------------------"
				<< std::endl;
		fgets(inpt, sizeof(inpt), stdin);
		switch (inpt[0])
		{
			case '1':
				ceService->Notify();
				break;
			case 'X':
			case 'x':
				goto end;
				break;
			default:
				std::cout << std::endl << "Invalid Selection" << std::endl;
				break;
		}
	}
	/* Terminate UDA at application side */
	status = (QStatus) UdaAppTerm();

	if (status != ER_OK)
	{
		printf("UDA Application Termination failed with error = %d", status);
		return status;
	}
	end: cleanup();

	return 0;
} /* main() */
