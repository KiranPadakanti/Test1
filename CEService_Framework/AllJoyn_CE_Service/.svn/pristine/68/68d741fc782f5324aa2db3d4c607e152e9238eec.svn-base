/**
 * @file
 * Transport is a base class for all Message Bus Transport implementations.
 */

/******************************************************************************
 *
 *
 * Copyright (c) 2009-2011, AllSeen Alliance. All rights reserved.
 *
 *    Permission to use, copy, modify, and/or distribute this software for any
 *    purpose with or without fee is hereby granted, provided that the above
 *    copyright notice and this permission notice appear in all copies.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 ******************************************************************************/
#include <qcc/platform.h>
#include <qcc/String.h>
#include <qcc/Debug.h>
#include <qcc/Thread.h>

#define QCC_MODULE "ALLJOYN"

using namespace std;
using namespace qcc;

#include "CECTransport.h"

#include <qcc/cecloader.h>
using namespace CEC;

namespace ajn {

bool CECTransport::instanceFlag = false;
bool CECTransport::libCecInitFlag = false;

CECTransport* CECTransport::cecInstance = NULL;

CECTransport* CECTransport::getCecInstance()
{
	if(! instanceFlag)
	{
		cecInstance = new CECTransport();
		instanceFlag = true;
		return cecInstance;
	}
	else
	{
		return cecInstance;
	}
}

int CecLogMessage(void *cbParam, const cec_log_message message)
{
  return 0;
}

int CecKeyPress(void *cbParam, const cec_keypress key)
{
  return 0;
}

int CecCommand(void *cbParam, const cec_command command)
{
	CECTransport *cec = CECTransport::getCecInstance();

    if(command.opcode == 0x84)
	{
    	if(!cec->devStatus[command.initiator])
    	{
    		cec->gAddDeviceCallbackFunc(command.initiator);
    		cec->devStatus[command.initiator] = true;
    	}
	}
	else
	{
    	cec->gCecIoCallbackFunc(command);
	}

	return 0;
}

void CECTransport::CecIoEnumeration(void)
{
	uint8_t dest;

	for (dest=0; dest<0xF; dest++)
	{
		if (dest == CEC_DEVICE_TYPE_RECORDING_DEVICE)
		{
			devStatus[dest] = true;
		}
		else if (parser->PollDevice((cec_logical_address) dest))
		{
			if(!devStatus[dest])
			{
				gAddDeviceCallbackFunc((cec_logical_address)dest);
				devStatus[dest] = true;
			}
		}
		else
		{
			if(devStatus[dest])
			{
				gDeleteDeviceCallbackFunc((cec_logical_address)dest);
				devStatus[dest] = false;
			}
		}
	}
}

void* HDMICableStatus(void *pArg)
{
	CECTransport *cec = CECTransport::getCecInstance();
	while(!cec->stopThread)
	{
	   cec->CecIoEnumeration();
	   Sleep(cec->pollTime);
	}
	cec->cecThread->Stop();
	return NULL;
}

QStatus CECTransport::CecIoRegisterRecvCecMesgCallback(
		CecIoCallbackFunc_t callbackFunc)
{
   	QStatus status(ER_OK);
	if (callbackFunc != NULL)
	{
		gCecIoCallbackFunc = callbackFunc;
	}
	else
	{
		status = ER_FAIL;
	}
	return status;
}

QStatus CECTransport::RegisterAddDeviceCallback(AddDevicecallbackFunc_t callbackFunc)
{
   	QStatus status(ER_OK);
	if (callbackFunc != NULL)
	{
		gAddDeviceCallbackFunc = callbackFunc;
	}
	else
	{
		status = ER_FAIL;
	}
	return status;
}

QStatus CECTransport::RegisterDeleteDeviceCallback(DeleteDevicecallbackFunc_t callbackFunc)
{
   	QStatus status(ER_OK);
	if (callbackFunc != NULL)
	{
		gDeleteDeviceCallbackFunc = callbackFunc;
	}
	else
	{
		status = ER_FAIL;
	}
	return status;
}

QStatus CECTransport::CecInit()
{
    	QStatus status(ER_OK);
		uint8_t dest;

	if(libCecInitFlag)
	{
   		 QCC_DbgPrintf(("Lib CEC already initialised \n"));
   		 status = ER_OK;
	}
	else
	{
		  for (dest=0; dest<0xF; dest++)
		  {
			devStatus[dest] = false;
		  }
    	  g_config.Clear();
    	  g_callbacks.Clear();
    	  snprintf(g_config.strDeviceName, 13, "CECTester");
    	  g_config.clientVersion       = CEC_CONFIG_VERSION;
    	  g_config.bActivateSource     = 0;
    	  g_callbacks.CBCecLogMessage  = &CecLogMessage;
    	  g_callbacks.CBCecKeyPress    = &CecKeyPress;
    	  g_callbacks.CBCecCommand     = &CecCommand;
    	  g_config.callbacks           = &g_callbacks;

    	  //Adding local device as Recording Device
    	  g_config.deviceTypes.Add(CEC_DEVICE_TYPE_RECORDING_DEVICE);

    	  parser = LibCecInitialise(&g_config);
    	  if (!parser)
    	  {
    		  QCC_LogError(status, ("Pulse-Eight Lib CEC Init Failed"));
    		  status = ER_FAIL;
    	  }

    	  // init video on targets that need this
    	  parser->InitVideoStandalone();

    	  if(parser->Open("/dev/ttyACM0", 10000))
    	  {
    		  QCC_DbgPrintf(("Successfully opened the Serial port\n"));
    	  }
    	  else
    	  {
    		  status = ER_FAIL;
    		  QCC_LogError(status, ("Opening of /dev/ttyACM0 Failed"));
    	  }

    	  // used to know the status of the devices on HDMI cable by polling
    	  CecIoEnumeration();

    	  // Create thread for Monitoring of HDMI cable status i.e Added & deleted cec devices.
    	  stopThread = false;
    	  cecThread = new Thread("HDMICableStatus",HDMICableStatus,false);
    	  cecThread->Start(NULL,NULL);

   		  QCC_DbgPrintf(("CECStart Success\n"));
   		  libCecInitFlag = true;
	}
    	  return status;
}

void CECTransport::SetPollInterval(int timems)
{
	pollTime = timems;
}

QStatus CECTransport::CecTerm()
{
   	QStatus status(ER_OK);
	if (parser)
	{
		stopThread = true;
		parser->Close();
        UnloadLibCec(parser);
 		QCC_DbgPrintf(("CECStop Success\n"));
	}
	else
	{
   		  status = ER_FAIL;
   		  QCC_LogError(status, ("No CECLibrary Instance exists\n"));
	}
	return status;
}

QStatus CECTransport::SendCecMesg(cec_command command)
{
   	QStatus status(ER_OK);

	if (!parser)
	{
   		  status = ER_FAIL;
   		  QCC_LogError(status, ("CECLibrary Not Initialised \n"));
	}
	else
	{
	if(parser->Transmit(command))
	{
		QCC_DbgPrintf(("command Transmitted succesfully\n"));
	}
	else
	{
		status = ER_FAIL;
		QCC_LogError(status,("command Transmission failed\n"));
	}
	}
	return status;
}

QStatus CECTransport::GetCecVersion(cec_logical_address dest, cec_version *versionPtr)
{
	QStatus status(ER_OK);
	if (!parser)
	{
		status = ER_FAIL;
   		QCC_LogError(status, ("CECLibrary Not Initialised \n"));
	}
	else
	{
		cec_version iVersion = parser->GetDeviceCecVersion(dest);
		*versionPtr = iVersion;
	}
	return status;
}

}

