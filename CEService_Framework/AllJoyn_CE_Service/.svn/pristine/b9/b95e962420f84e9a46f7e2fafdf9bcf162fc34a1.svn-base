/******************************************************************************
 *
 * Copyright 2008-2013, Silicon Image, Inc.  All rights reserved.
 * No part of this work may be reproduced, modified, distributed, transmitted,
 * transcribed, or translated into any language or computer format, in any form
 * or by any means without written permission of: Silicon Image, Inc., 1060
 * East Arques Avenue, Sunnyvale, California 94085
 *
 *****************************************************************************/
/**
 * @file os_file.h
 *
 * This file contains declarations to abstract file I/O
 *
 * Don't use source control directives!
 * Don't use source control directives!
 * Don't use source control directives!
 *
 *****************************************************************************/

#ifndef _OS_FILE_H
#define _OS_FILE_H

/** \addtogroup OSAL OS Abstraction Layer
 * @{
 * This provides the Abstraction Layer interface between ULMUS and OS library
 */

#include <stdio.h>
#include <dirent.h>
#include "sii_types.h"

/* NOTES:
 Thin layer to abstract minor differences in stdio file operations across OSs. General rules:
 -File functions have primarily been renamed with prefix 'SiiOsFile_t' and follow the original semantics. Refer to the corresponding Linux man pages for API documentation.
 -File data structures have been typedef'ed with prefix 'Sii'. Simple data types such as size_t have not been changed.
 -The stdio flags (such as w+) have not been re-defined with 'SII_' prefix. If any OS-specific translation is required,
 it will be done inside the functions below. Programmers should continue to use the flags applying the original stdio semantics.

 USE OF errno IS NOT ALLOWED for the file operations below. errno is not necessarily portable across OSs.
 */

typedef FILE SiiOsFile_t;
typedef DIR SiiOsDir_t;
typedef struct dirent SiiOsDirEnt_t;

#if (_FILE_OFFSET_BITS != 64)
#ifndef WIN32
#error "Need fopen64 for large file support, i.e. files longer than (2^31-1) bytes"
#endif
#endif

/**
 *  @name File
 *  @{
 **/

/************************************************************************//**
 *
 * @brief Open a file (public API)
 *
 * @param[in]     path            file path
 * @param[in]     mode            file open mode, see "man fopen"
 *
 * @return pointer to file descriptor
 * @retval NULL error
 *
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
SiiOsFile_t * SiiOsFileOpen(const char *path, const char *mode);

/************************************************************************//**
 *
 * @brief Close a file (public API)
 *
 * @param[in]     file            file descriptor from @ref SiiOsFileOpen()
 *
 * @retval 0 success
 * @retval EOF error
 *
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
int32_t SiiOsFileClose(SiiOsFile_t *file);

/************************************************************************//**
 *
 * @brief Read from a file (public API)
 *
 * @param[in]     ptr             destination buffer
 * @param[in]     size            size of a data element to be read
 * @param[in]     nmemb           number of data elements to be read
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 *
 * @return number of successfully read data elements
 *
 * @note An end-of-file situation causes a return value smaller than (nmemb).
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
size_t SiiOsFileRead(void *ptr, size_t size, size_t nmemb, SiiOsFile_t *stream);

/************************************************************************//**
 *
 * @brief Write to a file (public API)
 *
 * @param[in]     ptr             source buffer
 * @param[in]     size            size of a data element to be written
 * @param[in]     nmemb           number of data elements to be written
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 *
 * @return number of successfully written data elements
 *
 * @note An volume-full situation causes a return value smaller than (nmemb).
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
size_t SiiOsFileWrite(const void *ptr, size_t size, size_t nmemb,
		SiiOsFile_t *stream);

/************************************************************************//**
 *
 * @brief Seek to offset in a file (public API)
 *
 * @param[in]     stream        file descriptor from @ref SiiOsFileOpen()
 * @param[in]     offset        offset bytes.
 * @param[in]     whence        If whence is set to SEEK_SET, SEEK_CUR, or SEEK_END,
 * 								the offset is relative to the start of the  file,
 * 								the  current  position indicator,  or  end-of-file,  respectively.
 * @retval 0 success
 * @retval EOF error
 *
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
int32_t SiiOsFileSeek(SiiOsFile_t *stream, int32_t offset, int32_t whence);

/************************************************************************//**
 *
 * @brief Flush write buffer of a file (public API)
 *
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 *
 * @retval 0 success
 * @retval EOF error
 *
 * @note Only flushes the user-space buffers; hence we use fsync() to flush
 *       all the way to the physical drive.
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
int32_t SiiOsFileFlush(SiiOsFile_t *stream);

/************************************************************************//**
 *
 * @brief Get the current read/write position of a file (public API)
 *
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 * @param[out]    pos             current file position
 *
 * @retval 0  success
 * @retval -1 error
 *
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
int32_t SiiOsFileGetPos(SiiOsFile_t *stream, uint64_t *pos);

/************************************************************************//**
 *
 * @brief Set the current read/write position of a file (public API)
 *
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 * @param[out]    pos             current file position
 *
 * @retval 0  success
 * @retval -1 error
 *
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
int32_t SiiOsFileSetPos(SiiOsFile_t *stream, uint64_t *pos);

/************************************************************************//**
 *
 * @brief Set the file buffer for the buffered file output if the buf parameter
 *        is NULL the file is written directly without buffering
 *
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 * @param[out]    buf             buffer pointer
 *
 ******************************************************************************/
void SiiOsFileSetBuf(SiiOsFile_t *stream, int8_t *buf);

/************************************************************************//**
 *
 * @brief Get the current size of a file (public API)
 *
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 *
 * @retval file size on success
 * @retval -1   on error
 *
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
int64_t SiiOsFileSize(SiiOsFile_t *stream);

/************************************************************************//**
 *
 * @brief Read a line from stream (public API)
 *
 * @param[in]     line            pointer to read buffer
 * @param[in]     size            size of buffer
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 *
 * @return pointer to line
 * @retval NULL error
 *
 ******************************************************************************/
char * SiiOsFileGetLine(char *line, int size, SiiOsFile_t *stream);

/************************************************************************//**
 *
 * @brief Check EOF flag (public API)
 *
 * @param[in]     stream          file descriptor from @ref SiiOsFileOpen()
 *
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiOsFileIsEOF(SiiOsFile_t *stream);

/************************************************************************//**
 *
 * @brief Delete a file (public API)
 *
 * @param[in]     path            directory path
 *
 * @return returns 0 on success, -1 on failure
 ******************************************************************************/
uint32_t SiiOsFileDelete(const char *path);

/** @}*//* File */

/**
 *  @name Pipe
 *  @{
 **/
/************************************************************************//**
 *
 * @brief Open a pipe stream to a process (public API)
 *
 * @param[in]     cmd             command to execute
 * @param[in]     mode            open mode, see "man popen"
 *
 * @return pointer to file descriptor
 * @retval NULL error
 *
 ******************************************************************************/
SiiOsFile_t * SiiOsPipeOpen(const char *cmd, const char *mode);

/************************************************************************//**
 *
 * @brief Close a process opened by popen (public API)
 *
 * @param[in]     file            file descriptor from @ref SiiOsPipeOpen()
 *
 * @retval -1 error
 *
 ******************************************************************************/
int32_t SiiOsPipeClose(SiiOsFile_t *file);

/** @}*//* Pipe */

/**
 *  @name Directory
 *  @{
 **/

/************************************************************************//**
 *
 * @brief Open a directory (public API)
 *
 * @param[in]     path            directory path
 *
 * @return pointer to directory stream
 * @retval NULL error
 *
 * @note Use of 'errno' is NOT ALLOWED for checking status of file operations.
 *
 ******************************************************************************/
SiiOsDir_t * SiiOsDirOpen(const char *path);

/************************************************************************//**
 *
 * @brief Read a directory (public API)
 *
 * @param[in]     stream          directory stream descriptor from @ref SiiOsDirOpen()
 *
 * @return returns a pointer to a SiiOsDirEnt_t structure representing the next directory
 * entry in the directory stream pointed to by dirp.
 *
 * @note An end-of-steam is reached NULL is returned.
 *
 ******************************************************************************/
SiiOsDirEnt_t * SiiOsDirRead(SiiOsDir_t *stream);

/************************************************************************//**
 *
 * @brief Close a directory stream (public API)
 *
 * @param[in]     stream          directory stream descriptor from @ref SiiOsDirOpen()
 *
 * @return returns 0 on success, -1 on failure
 ******************************************************************************/
uint32_t SiiOsDirClose(SiiOsDir_t *stream);

/** @}*//* Directory */
/** @}*//* OS Abstraction Layer */

#endif /* _OS_FILE_H */
