#include <stdio.h>
#include <signal.h>

#include <alljoyn/BusAttachment.h>
#include <alljoyn/about/AboutIconService.h>
#include <alljoyn/about/AboutServiceApi.h>
#include <alljoyn/vendor/VendorService.h>

#include <CommonBusListener.h>
#include <CommonSampleUtil.h>

#include "VendorServiceListenerImpl.h"
#include "PropertyStoreImpl.h"
#include "OptParser.h"
#include <alljoyn/services_common/LogModulesNames.h>

#include <alljoyn/CECTransport.h>
#include <qcc/RWLock.h>

#define SERVICE_EXIT_OK       0
#define SERVICE_OPTION_ERROR  1

using namespace ajn;
using namespace services;

static CECTransport* cecPtr = NULL;
/** static variables need for sample */
static BusAttachment* msgBus = NULL;

static VendorService* vendorService = NULL;

static PropertyStoreImpl* propertyStore = NULL;

static VendorServiceListenerImpl* vendorServiceListener = NULL;

static CommonBusListener* busListener = NULL;

static SessionPort SERVICE_PORT;
qcc::RWLock *systemAddBufLock;
qcc::RWLock *systemDelBufLock;
int logical_address;

static void cleanup() {

	if (AboutServiceApi::getInstance()) {
		AboutServiceApi::DestroyInstance();
	}

	if (vendorService) {
		delete vendorService;
		vendorService = NULL;
	}

	if (vendorServiceListener) {
		delete vendorServiceListener;
		vendorServiceListener = NULL;
	}

	if (busListener) {
		msgBus->UnregisterBusListener(*busListener);
		delete busListener;
		busListener = NULL;
	}

	if (propertyStore) {
		delete propertyStore;
		propertyStore = NULL;
	}

	/* Clean up msg bus */
	delete msgBus;
	msgBus = NULL;

}

/** Advertise the service name, report the result to stdout, and return the status code. */
QStatus AdvertiseName(TransportMask mask) {
	QStatus status = ER_BUS_ESTABLISH_FAILED;
	if (msgBus->IsConnected() && msgBus->GetUniqueName().size() > 0) {
		status = msgBus->AdvertiseName(msgBus->GetUniqueName().c_str(), mask);
		//	std::cout << "AdvertiseName " << msgBus->GetUniqueName().c_str() << " ="
		//		<< QCC_StatusText(status) << std::endl;
	}
	return status;
}

/** Connect to the daemon, report the result to stdout, and return the status code. */
QStatus ConnectToDaemon() {
	QStatus status;
	status = msgBus->Connect();

	if (ER_OK == status) {
		//std::cout << "Daemon connect succeeded." << std::endl;
	} else {
		std::cout << "Failed to connect daemon (" << QCC_StatusText(status)
				<< ")." << std::endl;
	}

	return status;
}

/** Start the message bus, report the result to stdout, and return the status code. */
QStatus StartMessageBus(void) {
	QStatus status = msgBus->Start();

	if (ER_OK == status) {
		//std::cout << "BusAttachment started." << std::endl;
	} else {
		std::cout << "Start of BusAttachment failed (" << QCC_StatusText(status)
				<< ")." << std::endl;
	}

	return status;
}
void LaToString(int la, char *ptr) {
	int i = 0, j = 0;
	char *ptr1;
	ptr1 = (char *) cecPtr->parser->ToString((cec_logical_address) la);
	while (ptr1[i] != '\0') {
		if (ptr1[i] == ' ') {
			i++;
			continue;
		} else {
			ptr[j] = ptr1[i];
			i++;
			j++;
		}
	}
	ptr[j] = '\0';
	return;
}

char * LaToDeviceType(int la) {
	switch (la) {
	case CECDEVICE_TV:
		return "SINK_GEN";
	case CECDEVICE_PLAYBACKDEVICE1:
	case CECDEVICE_PLAYBACKDEVICE2:
	case CECDEVICE_PLAYBACKDEVICE3:
	case CECDEVICE_TUNER1:
	case CECDEVICE_TUNER2:
	case CECDEVICE_TUNER3:
	case CECDEVICE_TUNER4:
	case CECDEVICE_AUDIOSYSTEM:
		return "SOURCE_GEN";
	case CECDEVICE_UNKNOWN:
	case CECDEVICE_RECORDINGDEVICE1:
	case CECDEVICE_RECORDINGDEVICE2:
	case CECDEVICE_RECORDINGDEVICE3:
	case CECDEVICE_RESERVED1:
	case CECDEVICE_RESERVED2:
	case CECDEVICE_FREEUSE:
	case CECDEVICE_UNREGISTERED:
		return "UNKNOWN";
	}
	return "UNKNOWN";
}

void* AddDeviceThread(void *pArg) {
	char systemInBuf[200];
	char appName[100];
	int la;

	int *ptr1 = (int *) pArg;
	la = *ptr1;
	systemAddBufLock->Unlock();

	LaToString(la, appName);
	sprintf(systemInBuf, "ln -s LegacyDeviceSample %s", appName);
	system(systemInBuf);
	sprintf(systemInBuf, "./%s --la=%d --appName=%s --deviceType=%s",
			appName, la, appName, LaToDeviceType(la));
	system(systemInBuf);
	return NULL;
}

void AddDevicecallback(cec_logical_address la) {
	systemAddBufLock->WRLock();
	logical_address = la;
	Thread *addThread = new Thread("AddDeviceThread", AddDeviceThread, false);
	addThread->Start((void *) &logical_address, NULL);
}

void* DelDeviceThread(void *pArg) {
	int *ptr1 = (int *) pArg;
	char systemInBuf[200];
	char appName[100];
	int la;

	la = (int) *ptr1;
	systemDelBufLock->Unlock();

	LaToString(la, appName);
	sprintf(systemInBuf, "killall ./%s ", appName);
	system(systemInBuf);
	sprintf(systemInBuf, "rm %s", appName);
	system(systemInBuf);
	return NULL;
}

void DeleteDevicecallback(cec_logical_address la) {
	printf("Device deleted with %d", la);
	systemDelBufLock->WRLock();
	logical_address = la;
	Thread *delThread = new Thread("DelDeviceThread", DelDeviceThread, false);
	delThread->Start((void *) &logical_address, NULL);
}
void CecDiscIoCallback(cec_command command) {
	printf("CEC Command callback\n");
}

int main(int argc, char**argv, char**envArg) {
	QStatus status = ER_OK;
	char inpt[80] = { 0 };

	systemAddBufLock = new RWLock();
	systemDelBufLock = new RWLock();

//	std::cout << "AllJoyn Library version: " << ajn::GetVersion() << std::endl;
//	std::cout << "AllJoyn Library build info: " << ajn::GetBuildInfo()
//			<< std::endl;
//	QCC_SetLogLevels("ALLJOYN_ABOUT_SERVICE=7;");
//	QCC_SetLogLevels("ALLJOYN_ABOUT_ICON_SERVICE=7;");
//	QCC_SetDebugLevel(logModules::VENDOR_MODULE_LOG_NAME,
//			logModules::ALL_LOG_LEVELS);

	OptParser opts(argc, argv);
	OptParser::ParseResultCode parseCode(opts.ParseResult());
	switch (parseCode) {
	case OptParser::PR_OK:
		break;

	case OptParser::PR_EXIT_NO_ERROR:
		return SERVICE_EXIT_OK;

	default:
		return SERVICE_OPTION_ERROR;
	}

	SERVICE_PORT = opts.GetPort();
	std::cout << "using port " << opts.GetPort() << std::endl;

	if (!opts.GetAppId().empty()) {
		std::cout << "using appID " << opts.GetAppId().c_str() << std::endl;
	}

	/* Create message bus */
	msgBus = new BusAttachment(opts.GetAppName().c_str(), true);
	if (!msgBus) {
		status = ER_OUT_OF_MEMORY;
		return status;
	}

	if (ER_OK == status) {
		status = StartMessageBus();
	}

	if (ER_OK == status) {
		status = ConnectToDaemon();
	}

	busListener = new CommonBusListener(msgBus);
	busListener->setSessionPort(SERVICE_PORT);

	propertyStore = new PropertyStoreImpl(NULL, NULL);
	status = CommonSampleUtil::fillPropertyStore(propertyStore, opts.GetAppId(),
			opts.GetAppName(), opts.GetDeviceId(), opts.GetDeviceName(),
			opts.GetDefaultLanguage());
	propertyStore->Initialize();
	if (status != ER_OK) {
		std::cout << "Could not fill PropertyStore." << std::endl;
		cleanup();
		return 1;
	}

	status = CommonSampleUtil::prepareAboutService(msgBus, propertyStore,
			busListener, SERVICE_PORT);
	if (status != ER_OK) {
		std::cout << "Could not set up the AboutService." << std::endl;
		cleanup();
		return 1;
	}

	AboutService* aboutService = AboutServiceApi::getInstance();
	if (!aboutService) {
		std::cout << "Could not set up the AboutService." << std::endl;
		cleanup();
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	//VendorService
	vendorServiceListener = new VendorServiceListenerImpl(*busListener);
	vendorService = new VendorService(*msgBus, *propertyStore,
			*vendorServiceListener);

	std::vector<qcc::String> interfaces;
	interfaces.push_back("org.alljoyn.VENDOR");
	aboutService->AddObjectDescription("/VENDOR", interfaces);

	status = vendorService->Register();
	if (status != ER_OK) {
		std::cout << "Could not register the CEService." << std::endl;
		cleanup();
		return 1;
	}

	status = msgBus->RegisterBusObject(*vendorService);
	if (status != ER_OK) {
		std::cout << "Could not register the CEService BusObject." << std::endl;
		cleanup();
		return 1;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////
	const TransportMask SERVICE_TRANSPORT_TYPE = TRANSPORT_ANY;

	if (ER_OK == status) {
		status = AdvertiseName(SERVICE_TRANSPORT_TYPE);
	}

	if (ER_OK == status) {
		status = aboutService->Announce();
	}
	/////////////////////////////////////////////////////////////

	cecPtr = CECTransport::getCecInstance();

	cecPtr->SetPollInterval(60 * 1000);

	cecPtr->CecIoRegisterRecvCecMesgCallback(CecDiscIoCallback);
	cecPtr->RegisterAddDeviceCallback(AddDevicecallback);
	cecPtr->RegisterDeleteDeviceCallback(DeleteDevicecallback);

	if (cecPtr->CecInit() == ER_OK) {
		printf("CECStart() Success\n");
	} else {
		printf("CECStart() Failed\n");
	}

	/////////////////////////////////////////////////////////////

	/* Perform the service asynchronously until the user signals for an exit. */
	while (true) {
		std::cout << "\t----------------Main Menu-----------------"
				<< std::endl;
		std::cout << "\t|x) Exit                                  |"
				<< std::endl;
		std::cout << "\t------------------------------------------"
				<< std::endl;
		fgets(inpt, sizeof(inpt), stdin);
		switch (inpt[0]) {
		case 'X':
		case 'x':
			goto end;
			break;
		default:
			std::cout << std::endl << "Invalid Selection" << std::endl;
			break;
		}
	}

	end: cleanup();
	cecPtr->CecTerm();
	return 0;
} /* main() */
