#include <stdio.h>
#include <signal.h>
#include <fstream>

#include <alljoyn/BusAttachment.h>
#include <alljoyn/about/AboutIconService.h>
#include <alljoyn/about/AboutServiceApi.h>
#include <alljoyn/ce/CEService.h>
#include <alljoyn/ce/CEKeyCodes.h>

#include <CommonBusListener.h>
#include <CommonSampleUtil.h>

#include "LegacyDeviceListenerImpl.h"
#include "PropertyStoreImpl.h"
#include "OptParser.h"
#include <alljoyn/services_common/LogModulesNames.h>

#include "unistd.h"
#include "sii_types.h"
#include "uda.h"

#include <AnnounceHandlerImpl.h>
#include <alljoyn/about/AnnouncementRegistrar.h>
#include <alljoyn/vendor/SessionListener.h>
#include <alljoyn/vendor/VendorClient.h>

#include <alljoyn/CECTransport.h>

#define SERVICE_EXIT_OK       0
#define SERVICE_OPTION_ERROR  1

using namespace ajn;
using namespace services;
using namespace vendor;

/** static variables need for sample */
BusAttachment* msgBus = NULL;

static CEService* ceService = NULL;

static AboutIconService* aboutIconService = NULL;

static PropertyStoreImpl* propertyStore = NULL;

static LegacyDeviceListenerImpl* legacyServiceListener = NULL;

static CommonBusListener* busListener = NULL;

static SessionPort SERVICE_PORT;

static AnnounceHandlerImpl* announceHandler = NULL;

qcc::String vendorBusName;

ajn::SessionId vendorSessionId;

static SessionListenerImpl* sessionListnr;

static void cleanup()
{

	if (AboutServiceApi::getInstance())
	{
		AboutServiceApi::DestroyInstance();
	}

	if (ceService)
	{
		delete ceService;
		ceService = NULL;
	}

	if (legacyServiceListener)
	{
		delete legacyServiceListener;
		legacyServiceListener = NULL;
	}

	if (busListener)
	{
		msgBus->UnregisterBusListener(*busListener);
		delete busListener;
		busListener = NULL;
	}

	if (aboutIconService)
	{
		delete aboutIconService;
		aboutIconService = NULL;
	}

	if (propertyStore)
	{
		delete propertyStore;
		propertyStore = NULL;
	}

	AnnouncementRegistrar::UnRegisterAnnounceHandler(*msgBus,
			*announceHandler);

	delete announceHandler;

	/* Clean up msg bus */
	delete msgBus;
	msgBus = NULL;

}

/** Advertise the service name, report the result to stdout, and return the status code. */
QStatus AdvertiseName(TransportMask mask)
{
	QStatus status = ER_BUS_ESTABLISH_FAILED;
	if (msgBus->IsConnected() && msgBus->GetUniqueName().size() > 0)
	{
		status = msgBus->AdvertiseName(msgBus->GetUniqueName().c_str(), mask);
		//	std::cout << "AdvertiseName " << msgBus->GetUniqueName().c_str() << " ="
		//		<< QCC_StatusText(status) << std::endl;
	}
	return status;
}

/** Connect to the daemon, report the result to stdout, and return the status code. */
QStatus ConnectToDaemon()
{
	QStatus status;
	status = msgBus->Connect();

	if (ER_OK == status)
	{
		//std::cout << "Daemon connect succeeded." << std::endl;
	}
	else
	{
		std::cout << "Failed to connect daemon (" << QCC_StatusText(status)
				<< ")." << std::endl;
	}

	return status;
}

/** Start the message bus, report the result to stdout, and return the status code. */
QStatus StartMessageBus(void)
{
	QStatus status = msgBus->Start();

	if (ER_OK == status)
	{
		//std::cout << "BusAttachment started." << std::endl;
	}
	else
	{
		std::cout << "Start of BusAttachment failed (" << QCC_StatusText(status)
				<< ")." << std::endl;
	}

	return status;
}

void sessionLostCallback(ajn::SessionId sessionId,
		ajn::SessionListener::SessionLostReason reason)
{
	std::cout << sessionId << " lost from network with " << reason << std::endl;
}

void sessionJoinedCallback(qcc::String const& busName, SessionId id)
{
	msgBus->EnableConcurrentCallbacks();
	vendorBusName = qcc::String(busName);
	vendorSessionId = id;
	std::cout << std::endl << __FUNCTION__ << " Session Joined: busName "
			<< vendorBusName.c_str() << " Session ID " << vendorSessionId
			<< std::endl;
	return;
}

void announceHandlerCallback(qcc::String const& busName, unsigned short version,
		unsigned short port,
		const ajn::services::AnnounceHandler::ObjectDescriptions& objectDescs,
		const ajn::services::AnnounceHandler::AboutData& aboutData)
{
	AboutClient* aboutClient = new AboutClient(*msgBus);
	if (aboutClient)
	{
		qcc::String ceInterfacename;
		ceInterfacename.assign("/VENDOR");
		AnnounceHandler::ObjectDescriptions::const_iterator itr =
				objectDescs.find(qcc::String(ceInterfacename));
		if (itr == objectDescs.end())
		{
			AnnounceHandler::AboutData::const_iterator search = aboutData.find(
					"AppName");
			if (search != aboutData.end())
			{
				qcc::String key = search->first;
				ajn::MsgArg value = search->second;
				if (value.typeId == ALLJOYN_STRING)
				{

					std::cout << "Not a Vendor Service App Ignoring:"
							<< value.v_string.str << std::endl;

				}
			}

			return;
		}
	}
	else
	{
		return;
	}
	SessionOpts opts(SessionOpts::TRAFFIC_MESSAGES, false,
			SessionOpts::PROXIMITY_ANY, TRANSPORT_ANY);
	sessionListnr = new SessionListenerImpl(busName, sessionLostCallback);
	AsyncSessionJoiner* joincb = new AsyncSessionJoiner(busName.c_str(),
			sessionJoinedCallback);

	QStatus status = msgBus->JoinSessionAsync(busName.c_str(), port,
			sessionListnr, opts, joincb, sessionListnr);

	if (status != ER_OK)
	{
		std::cout << "Unable to JoinSession with " << busName.c_str()
				<< std::endl;
	}
}

int main(int argc, char**argv, char**envArg)
{
	QStatus status = ER_OK;
	char inpt[80] = { 0 };
	std::set<unsigned int> keyList;
	unsigned char lKsup[32] = { 0 };
	unsigned int la = 0;
//	std::cout << "AllJoyn Library version: " << ajn::GetVersion() << std::endl;
//	std::cout << "AllJoyn Library build info: " << ajn::GetBuildInfo()
//			<< std::endl;
//	QCC_SetLogLevels("ALLJOYN_ABOUT_SERVICE=7;");
//	QCC_SetLogLevels("ALLJOYN_ABOUT_ICON_SERVICE=7;");
//	QCC_SetDebugLevel(logModules::VENDOR_MODULE_LOG_NAME,
//			logModules::ALL_LOG_LEVELS);

	OptParser opts(argc, argv);
	OptParser::ParseResultCode parseCode(opts.ParseResult());
	switch (parseCode)
	{
		case OptParser::PR_OK:
			break;

		case OptParser::PR_EXIT_NO_ERROR:
			return SERVICE_EXIT_OK;

		default:
			return SERVICE_OPTION_ERROR;
	}

	SERVICE_PORT = opts.GetPort();
	std::cout << "using port " << opts.GetPort() << std::endl;

	if (!opts.GetAppId().empty())
	{
		std::cout << "using appID " << opts.GetAppId().c_str() << std::endl;
	}

	la = opts.GetLA();

	printf("Logical Address of device is %d\n",la);

	/* Create message bus */
	msgBus = new BusAttachment(opts.GetAppName().c_str(), true);
	if (!msgBus)
	{
		status = ER_OUT_OF_MEMORY;
		return status;
	}

	if (ER_OK == status)
	{
		status = StartMessageBus();
	}

	if (ER_OK == status)
	{
		status = ConnectToDaemon();
	}

	busListener = new CommonBusListener(msgBus);
	busListener->setSessionPort(SERVICE_PORT);

	propertyStore = new PropertyStoreImpl(NULL, NULL);
	status = CommonSampleUtil::fillPropertyStore(propertyStore, opts.GetAppId(),
			opts.GetAppName(), opts.GetDeviceId(), opts.GetDeviceName(),
			opts.GetDefaultLanguage());
	propertyStore->Initialize();
	if (status != ER_OK)
	{
		std::cout << "Could not fill PropertyStore." << std::endl;
		cleanup();
		return 1;
	}

	status = CommonSampleUtil::prepareAboutService(msgBus, propertyStore,
			busListener, SERVICE_PORT);
	if (status != ER_OK)
	{
		std::cout << "Could not set up the AboutService." << std::endl;
		cleanup();
		return 1;
	}

	AboutService* aboutService = AboutServiceApi::getInstance();
	if (!aboutService)
	{
		std::cout << "Could not set up the AboutService." << std::endl;
		cleanup();
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	//aboutIconService
	std::ifstream infile("icon.png", std::ifstream::binary);

	// get size of file
	infile.seekg(0, infile.end);
	long size = infile.tellg();
	infile.seekg(0);

	// allocate memory for file content
	uint8_t* aboutIconContent = new uint8_t[size];
	// read content of infile
	infile.read((char *) aboutIconContent, size);
	infile.close();

	qcc::String mimeType("image/png");
	qcc::String url(""); //put your url here

	std::vector<qcc::String> interfaces;
	interfaces.push_back("org.alljoyn.Icon");
	aboutService->AddObjectDescription("/About/DeviceIcon", interfaces);

	aboutIconService = new AboutIconService(*msgBus, mimeType, url,
			(uint8_t *) aboutIconContent, size);
	status = aboutIconService->Register();
	if (status != ER_OK)
	{
		std::cout << "Could not register the AboutIconService." << std::endl;
		cleanup();
		return 1;
	}

	status = msgBus->RegisterBusObject(*aboutIconService);
	if (status != ER_OK)
	{
		std::cout << "Could not register the AboutIconService BusObject."
				<< std::endl;
		cleanup();
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	//CEService
	CEKeyCodes obj = CEKeyCodes();
	obj.getKeyListfromDeviceType(opts.GetDeviceType(), &keyList);
	obj.getKSUPfromKeyList(keyList, lKsup);
	legacyServiceListener = new LegacyDeviceListenerImpl(*busListener, la);
	ceService = new CEService(*msgBus, *propertyStore, *legacyServiceListener,
			opts.GetDeviceType(), lKsup);

	interfaces.clear();
	interfaces.push_back("org.alljoyn.CE");
	aboutService->AddObjectDescription("/CE", interfaces);

	status = ceService->Register();
	if (status != ER_OK)
	{
		std::cout << "Could not register the CEService." << std::endl;
		cleanup();
		return 1;
	}

	status = msgBus->RegisterBusObject(*ceService);
	if (status != ER_OK)
	{
		std::cout << "Could not register the CEService BusObject." << std::endl;
		cleanup();
		return 1;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////

	announceHandler = new AnnounceHandlerImpl(0,
			announceHandlerCallback);
	AnnouncementRegistrar::RegisterAnnounceHandler(*msgBus,
			*announceHandler);

	msgBus->AddMatch("sessionless='t',type='error'");

	/* UDA Application Initialization. Return with error if initialization fails */
	status =(QStatus) udaAppInit();
	if (status != ER_OK)
	{
		printf("AppInit failed.. exiting");
		return 1;
	}

	const TransportMask SERVICE_TRANSPORT_TYPE = TRANSPORT_ANY;

	if (ER_OK == status)
	{
		status = AdvertiseName(SERVICE_TRANSPORT_TYPE);
	}

	if (ER_OK == status)
	{
		status = aboutService->Announce();
	}

				VendorClient* vendorClient = NULL;
				vendorClient = new VendorClient(*msgBus);
	/* Perform the service asynchronously until the user signals for an exit. */
	while (true)
	{
		std::cout << "\t----------------Main Menu-----------------"
				<< std::endl;
		std::cout << "\t|1) Send Notify                           |"
				<< std::endl;
		std::cout << "\t|2) Send VendorSendCECommand              |"
				<< std::endl;
		std::cout << "\t|x) Exit                                  |"
				<< std::endl;
		std::cout << "\t------------------------------------------"
				<< std::endl;
		fgets(inpt, sizeof(inpt), stdin);
		switch (inpt[0])
		{
			case '1':
				ceService->Notify();
				break;
			case '2':
				if(vendorClient)
				{
				std::cout << "before  VendorSendCECommand(): " << vendorBusName.c_str() << " sessionId "
						<< vendorSessionId << std::endl;
				vendorClient->VendorSendCECommand(vendorBusName.c_str(),
						(unsigned int) 0xCE000005, (unsigned int) 0x01,
						vendorSessionId);
				}
				else
				{
				std::cout << "VendorClient() returned null " <<std::endl;
				}
				break;
			case 'X':
			case 'x':
				goto end;
				break;
			default:
				std::cout << std::endl << "Invalid Selection" << std::endl;
				break;
		}
	}
	/* Terminate UDA at application side */
	status = (QStatus)UdaAppTerm();

	if (status != ER_OK)
	{
		printf("UDA Application Termination failed with error = %d", status);
		return status;
	}
	end: cleanup();

	return 0;
} /* main() */
