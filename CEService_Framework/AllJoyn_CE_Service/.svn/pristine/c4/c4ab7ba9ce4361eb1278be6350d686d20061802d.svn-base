#include <stdio.h>
#include <signal.h>
#include <set>
#include <fstream>
#include <iostream>
#include <map>
#include <iomanip>

#include <alljoyn/about/AnnouncementRegistrar.h>
#include <alljoyn/vendor/VendorClient.h>
#include <alljoyn/vendor/SessionListener.h>

#include <AnnounceHandlerImpl.h>
#include <alljoyn/services_common/LogModulesNames.h>

using namespace ajn;
using namespace services;
using namespace vendor;

static qcc::String vendorBusName;
static ajn::SessionId vendorSessionId;

static BusAttachment* busAttachment = 0;

SessionListenerImpl* sessionListnr;

void sessionLostCallback(ajn::SessionId sessionId,
		ajn::SessionListener::SessionLostReason reason)
{
	std::cout << sessionId << " lost from network with " << reason << std::endl;
}

void sessionJoinedCallback(qcc::String const& busName, SessionId id)
{
	busAttachment->EnableConcurrentCallbacks();
	vendorBusName = qcc::String(busName);
	vendorSessionId = id;
	std::cout << std::endl << __FUNCTION__ << " Session Joined: busName "
			<< vendorBusName.c_str() << " Session ID " << vendorSessionId
			<< std::endl;
	return;
}

void announceHandlerCallback(qcc::String const& busName, unsigned short version,
		unsigned short port,
		const ajn::services::AnnounceHandler::ObjectDescriptions& objectDescs,
		const ajn::services::AnnounceHandler::AboutData& aboutData)
{
	AboutClient* aboutClient = new AboutClient(*busAttachment);
	if (aboutClient)
	{
		qcc::String ceInterfacename;
		ceInterfacename.assign("/VENDOR");
		AnnounceHandler::ObjectDescriptions::const_iterator itr =
				objectDescs.find(qcc::String(ceInterfacename));
		if (itr == objectDescs.end())
		{
			AnnounceHandler::AboutData::const_iterator search = aboutData.find(
					"AppName");
			if (search != aboutData.end())
			{
				qcc::String key = search->first;
				ajn::MsgArg value = search->second;
				if (value.typeId == ALLJOYN_STRING)
				{

					std::cout << "Not a Vendor Service App Ignoring:"
							<< value.v_string.str << std::endl;

				}
			}

			return;
		}
	}
	else
	{
		return;
	}
	SessionOpts opts(SessionOpts::TRAFFIC_MESSAGES, false,
			SessionOpts::PROXIMITY_ANY, TRANSPORT_ANY);
	sessionListnr = new SessionListenerImpl(busName, sessionLostCallback);
	AsyncSessionJoiner* joincb = new AsyncSessionJoiner(busName.c_str(),
			sessionJoinedCallback);

	QStatus status = busAttachment->JoinSessionAsync(busName.c_str(), port,
			sessionListnr, opts, joincb, sessionListnr);

	if (status != ER_OK)
	{
		std::cout << "Unable to JoinSession with " << busName.c_str()
				<< std::endl;
	}
}

int main(int argc, char**argv, char**envArg)
{
	QStatus status = ER_OK;

//	QCC_SetLogLevels("ALLJOYN_ABOUT_CLIENT=7");
//	QCC_SetLogLevels("ALLJOYN_ABOUT_ICON_CLIENT=7");
//	QCC_SetLogLevels("ALLJOYN_ABOUT_ANNOUNCE_HANDLER=7");
//	QCC_SetDebugLevel(logModules::VENDOR_MODULE_LOG_NAME,
//			logModules::ALL_LOG_LEVELS);
	char usrInput[80] = { 0 };

	busAttachment = new BusAttachment("VendorClient", true);

	status = busAttachment->Start();
	if (status == ER_OK)
	{
		//std::cout << "BusAttachment started." << std::endl;
	}
	else
	{
		std::cout << "Unable to start BusAttachment. Status: "
				<< QCC_StatusText(status) << std::endl;
		return 1;
	}

	status = busAttachment->Connect();
	if (ER_OK == status)
	{
		//std::cout << "Daemon Connect succeeded." << std::endl;
	}
	else
	{
		std::cout << "Failed to connect daemon. Status: "
				<< QCC_StatusText(status) << std::endl;
		return 1;
	}

	AnnounceHandlerImpl* announceHandler = new AnnounceHandlerImpl(0,
			announceHandlerCallback);
	AnnouncementRegistrar::RegisterAnnounceHandler(*busAttachment,
			*announceHandler);

	busAttachment->AddMatch("sessionless='t',type='error'");

	VendorClient* vendorClient = NULL;
	vendorClient = new VendorClient(*busAttachment);

	if (vendorClient)
	{
		while (1)
		{
			std::cout << "\t----------------Main Menu-----------------"
					<< std::endl;
			std::cout << "\t|1) Send Command                          |"
					<< std::endl;
			std::cout << "\t|x) Exit                                  |"
					<< std::endl;
			std::cout << "\t------------------------------------------"
					<< std::endl;
			fgets(usrInput, sizeof(usrInput), stdin);
			switch (usrInput[0])
			{
				case '1':
					vendorClient->VendorSendCECommand(vendorBusName.c_str(),
							(unsigned int) 0xCE000005, (unsigned int) 1,
							vendorSessionId);
					break;
				case 'X':
				case 'x':
					goto end;
					break;
				default:
					std::cout << std::endl << "Invalid Selection" << std::endl;
					break;
			}
		}
	}
	end: AnnouncementRegistrar::UnRegisterAnnounceHandler(*busAttachment,
			*announceHandler);

	delete announceHandler;
	delete vendorClient;
	busAttachment->Stop();
	delete busAttachment;

} /* main() */
